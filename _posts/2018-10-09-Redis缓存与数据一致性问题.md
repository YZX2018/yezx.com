---
layout: post
title: "Redis缓存与数据一致性问题"
date: 2018-10-09
tags: java
---

对于读多写少的高并发场景，我们会经常使用缓存来进行优化。比如说支付宝的余额展示功能，实际上99%的时候
都是查询，1%的请求是变更（除非是土豪，每秒钟都有收入在不断更改余额），所以，我们在这样的场景下，可
以加入缓存，用户->余额
![image.png](https://upload-images.jianshu.io/upload_images/14890912-89d0835503ee12f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

>#Redis缓存与数据一致性问题
>那么基于上面的这个出发点，问题就来了，当用户的余额发生变化的时候，如何更新缓存中的数据，也就是说。
>\1. 我是先更新缓存中的数据再更新数据库的数据；
>\2. 还是修改数据库中的数据再更新缓存中的数据
>这就是我们经常会在面试遇到的问题，数据库的数据和缓存中的数据如何达到一致性？首先，可以肯定的是，redis中的数据和数据库中的数据不可能保证事务性达到统一的，这个是毫无疑问的，所以在实际应用中，我们都是基于当前的场景进行权衡降低出现不一致问题的出现概率
>######更新缓存还是让缓存失效
>更新缓存表示数据不但会写入到数据库，还会同步更新缓存； 而让缓存失效是表示只更新数据库中的数据，然后删除缓存中对应的key。那么这两种方式怎么去选择？这块有一个衡量的指标。
>\1. 如果更新缓存的代价很小，那么可以先更新缓存，这个代价很小的意思是我不需要很复杂的计算去获得最新的余额数字。
>\2. 如果是更新缓存的代价很大，意味着需要通过多个接口调用和数据查询才能获得最新的结果，那么可以先淘汰缓存。淘汰缓存以后后续的请求如果在缓存中找不到，自然去数据库中检索。
>######先操作数据库还是先操作缓存？
>当客户端发起事务类型请求时，假设我们以让缓存失效作为缓存的的处理方式，那么又会存在两个情况，
>\1. 先更新数据库再让缓存失效
>\2. 先让缓存失效，再更新数据库
>前面我们讲过，更新数据库和更新缓存这两个操作，是无法保证原子性的，所以我们需要根据当前业务的场景的容忍性来选择。也就是如果出现不一致的情况下，哪一种更新方式对业务的影响最小，就先执行影响最小的方案。然后通过MQ来解决最终一致性