java浅拷贝与深拷贝

当我们需要把DTO的属性复制到Entity时，会使用get、set方法对每个属性进行操作，如果属性有N多个，就会非常麻烦，这时我们可以使用java对象拷贝。

java对象拷贝分为**浅拷贝**和**深拷贝**

<font color=#FF0000>**浅拷贝和深拷贝的主要区别在于是否支持引用类型的成员变量的复制**</font>

这时我们就要清楚Java中的数据类型分为基本数据类型和引用数据类型

<font color=#0099ff>**浅拷贝：拷贝时创建一个新的对象，对象中的属性如果是基本数据类型会新创建的对象，但是属性是引用类型不会创建新的对象，而是使用与之前的对象指向同一个内存地址**</font>

<font color=#0099ff>**深拷贝：拷贝时创建一个新的对象，并且所有属性都是新对象(指向新的内存地址)**</font>



**我们使用代码来解释<font color=#0099ff>浅拷贝</font>，使用Entity对象复制一个DTO**



![img](https://mmbiz.qpic.cn/mmbiz_png/R3mA97JORjp0IBYpsXPZwBd0hGthibPe9lg0F5MD2Wxet1G2DEmiaMHdHBgOHicHgJaibkscODpK9Y0ATBTxOlxicqA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



![img](https://mmbiz.qpic.cn/mmbiz_png/R3mA97JORjp0IBYpsXPZwBd0hGthibPe9Xq29C8pM3ZfCDSb5Bq9UQ9grLoFwkDLhJGicwx6zVW608yS8bb9jkOQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

![img](https://mmbiz.qpic.cn/mmbiz_png/R3mA97JORjp0IBYpsXPZwBd0hGthibPe9CbR7sicWXEM46vsH7F9fbHkLkVibEdnfuxfpJo7brRdF6t9ibiawq7hBicA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

现在进行对象浅拷贝

![img](https://mmbiz.qpic.cn/mmbiz_png/R3mA97JORjp0IBYpsXPZwBd0hGthibPe9rWJXeeaWAgU92hibwUAcCOdVQ1ZH7gRicQ4TsfYtSfbhkgGvYdCFFk8Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

打印结果，entity对象的值已经成功复制到dto中

![img](https://mmbiz.qpic.cn/mmbiz_png/R3mA97JORjp0IBYpsXPZwBd0hGthibPe9dSvJBUk4jpq88P0QMCnNJjIs24bGUqTf4GNuRFANTJE6kKNqUW9yQQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

现在我们来证实一下浅拷贝的特点(引用类型指向原对象的内存地址)

![img](https://mmbiz.qpic.cn/mmbiz_png/R3mA97JORjp0IBYpsXPZwBd0hGthibPe9BM7IicaJNO0UeXYRjApraKQ1G3BRGgtVNRib8ibbFicxnviaqgk9Dib4YZjA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

打印结果，发现entity和dto属性的helloDTO都修改了成777777了

![img](https://mmbiz.qpic.cn/mmbiz_png/R3mA97JORjp0IBYpsXPZwBd0hGthibPe9gOrNNYCGGPJcVqxVtAAjj7dOyx6TibByN0Uxl5ickKiaxXRO4iafT6dWmg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

可以得出浅拷贝entity和testDTO都是引用了同一个helloDTO对象

但我测试了<font color=#FF0000>基本数组和枚举并不是引用同一个对象。这里没有截图</font>

结论：浅拷贝复制的引用类型(但不包括数组和枚举)与原对象指向同一个内存地址



下面我们验证一下<font color=#FF0000>深拷贝，这里使用IO流的方式进行深拷贝</font>





![img](https://mmbiz.qpic.cn/mmbiz_png/R3mA97JORjp0IBYpsXPZwBd0hGthibPe9Lv1QWibsLM88ibkr0gcFicia8H0t27oYU7LZHamXvmVMtiaibeAzWVMtmR6A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

打印结果

![img](https://mmbiz.qpic.cn/mmbiz_png/R3mA97JORjp0IBYpsXPZwBd0hGthibPe98baYib1ODMXZH63j2Aw1dRQ7XNZs3awpowA4cS9yDDMHljB1icoAVTibQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

发现修改HelloDTO属性后，只有原来的entity对象的属性值修改了，拷贝出来的entity对象的属性值并没有变化。

可以得出深拷贝拷贝出来的是新的对象(内存地址)



总结：

浅拷贝和深拷贝都会把相同类型和名称的属性值复制到目标类中，区别在于

<font color=#FF0000>浅拷贝对于引用类型(但不包括数组和枚举)的属性只是引用原对象的内存地址(同一个对象)，</font>

<font color=#FF0000>深拷贝是所有属性都创建新的对象</font>



<font color=#00BFFF>**另外注意上面用到的使用IO流进行深拷贝，只能是同一种类型才行。并不能实现entity类转dto类。所有这种方式并不实用。百度谷歌上搜索出来的答案的方式也都只能是同类型的转换，个人感觉并没有多大用处，如果需要不同类型的转换，可能要用上反射或者字节码的操作了**。</font>