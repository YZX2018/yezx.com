---
layout: post
title: "分布式事务之MQ可靠消息"
date: 2018-09-26
tags: java
---

CAP：
C:一致性、A:可用性、P：分区容错性(出现网络延迟)

BASE
基本可用(搜索1s变成2s、降级页面(当前访问量过多))
软状态 (状态机) 中间状态 如支付时的交易处理中状态
数据最终一致性 (基于MQ)


高可用高设计
1.避免单点故障
  a)负载均衡技术
  b)热备
  c)多机房(同城灾备、异地灾备)
2.应用的高可用性
  a)故障监控(系统监控(cpu、内存))、链路监控、日志监控   的自动预警
  b)应用的容错计设、服务降级、限流
  c)数据量(数据分片、读写分离)

----------------------------------------------------------
分布式事务：在微服务中，一个服务调用另一个服务的接口操作数据库。
比如支付服务在支付后调用订单服务接口修改订单表的支付状态。
正常情况下，代码出现了异常，支付服务只能回滚自己的数据库。不能回滚订单服务的数据库


分布式事务解决方案：
2PC(两段提交协议)、3PC(三段提交协议)、TCC(阿里写的框架)、MQ（补偿机制、重试），
其他补偿方式（回调） 如支付流程、
jta(java操作xa(分布式事务协调)接口)+Automatic(只适用于传统项目的多数据库)         底层采用2PC
CPA理论和base理论 柔性事务和刚性事务
LCN框架

#分布式理论
CPA理论：
1.数据一致性、
2.服务可用性(所有读写请求在一定时间内得到响应，可终止、不会一直等待)、
3.分区容错(一个服务挂了不会影响到整体服务  高可用)


Base理论：
1.基本可用
2.软状态
3.最终一致性

BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的。BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。


柔性事务和刚性事务
柔性事务满足BASE理论（基本可用，最终一致）
刚性事务满足ACID理论

#2PC两段提交协议
![image.png](https://upload-images.jianshu.io/upload_images/14890912-083207a5a81c4477.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![image.png](https://upload-images.jianshu.io/upload_images/14890912-1820b40413be514f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


全局事务：将多个事物进行统一管理

第一次提交：协调者给每个参与者发一个预备通知，支付数据库和订单数据库回复给协调者是否可以提交事务
(作用：确认业务逻辑执行没有任何异常)

第二次提交：协调者给每个参数与发一个通知 ，进行commit



3PC与两阶段提交不同的是，三阶段提交有两个改动点。
1、引入超时机制。同时在协调者和参与者中都引入超时机制。

2、在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。


#MQ解决分布式事务

使用MQ消息中间件 异步通知 ，点对点 解决高并发
MQ最终能够实现数据一致性 重试机制。补偿机制   要注意重复消费的幂等性问题(使用全局id+日志记录)


MQ解决分布式事务：  底层base理论，柔性事务(基本可用，最终一致性)

支付服务(生产者)状态支付状态通过MQ存到队列中，然后订单服务(消费者)进行对订单的修改。
但这样会出现延迟。但没有太大影响。基本上很快

>
>
>使用MQ可靠消息能够解决分布式事务的**最终一致性，**但不是实时一致(强一致性)。所以使用时要注意应用场景。
>
>MQ可靠消息：
>
>1.预发消息：MQ发送消息之前把消息的信息先存到数据库中留底，设置一个字段状态为待确认。(作用：能够知道这条消息是否发送成功，可进行人工补偿)
>
>2.进行业务操作
>
>3.向MQ发送消息，发送成功后把预发消息的状态改为发送中(表示成功发送)，如果失败就不需要修改
>
>应用场景：充值业务  订单->账务
>
>充值成功后
>
>第一步，将消息的信息先存到数据库中留底，设置一个字段状态为待确认(预发消息)
>
>第二步，修改充值的订单状态为充值功能
>
>第三步，发送MQ消息到账务系统，通知账务系统记录订单的账务明细
>
>
>
>特殊MQ可靠消息保证事务的场景：用户短时间多笔消费  订单->账户扣款
>
>如果消费时，先修改订单状态，再扣款。有10笔订单的消费状态都修成了成功，但是账户的余额不够钱扣除10笔订单。这样就会出问题了
>
>解决的方案：用户消费时，先扣款再修改订单
>
>不能使用MQ可靠消息保证事务的场景：交易完成后既要 **扣款** 也要 **减库存**。这种场场景要使用强一致性事务





#LCN分布式事务框架v3.0   https://www.txlcn.org

LCN:不生产事务，只是事务的协调者   LCN 核心采用3PC+TCC补偿机制
原理：发起方(如支付服务)需要调用其他服务接口(如订单服务)的时候，会在tx-manager创建一个事务分组，重写feign接口，在Http请求头上面把分组id传给参与方(订单服务)，参与方在Http请求头上收到分组id的时候，执行完不会提交事务，要等发起方代码执行完后，通知给tx-manager是提交还是回滚，然后tx-manager通知给参与方做事务处理

核心步骤
创建事务组
是指在事务发起方开始执行业务代码之前先调用TxManager创建事务组对象，然后拿到事务标示GroupId的过程。
添加事务组
添加事务组是指参与方在执行完业务方法以后，将该模块的事务信息添加通知给TxManager的操作。
关闭事务组
是指在发起方执行完业务代码以后，将发起方执行结果状态通知给TxManager的动作。当执行完关闭事务组的方法以后，TxManager将根据事务组信息来通知相应的参与模块提交或回滚事务。
![image.png](https://upload-images.jianshu.io/upload_images/14890912-74b586cd09e7bcbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)